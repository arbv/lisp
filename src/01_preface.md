# К читателю

Несмотря на то, что литературы на тему Лиспа существует достаточно много
и она вполне доступна для понимания, эта книга имеет свою нишу.
Программирование требует владения фундаментальными основами языка.
Для Лиспа и Scheme ими являются нетривиальные вещи вроде функций высшего порядка,
объектов, продолжений и тому подобного.
Их незнание и непонимание преграждает вам путь в будущее,
так как то, что ещё сегодня считалось продвинутым знанием,
завтра уже станет нормой для образованного человека.

Мы собираемся в деталях прояснить природу данных сущностей, их истоки и разновидности.
Ходит поговорка, что лисперы знают ценность каждого выражания в программе, но не ведают их цены.
Поэтому мы также постараемся сократить эту пропасть в понимании языка с помощью детального изучения его семантики,
а также реализации различных возможностей Лиспа, которые были изобретены за его
более чем тридцатилетнюю историю.

Лисп — это приятный язык программирования,
на котором многие фундаментальные и сложные вещи выражаются простым образом.
Вместе с ML — своим строго типизированным собратом, (почти) лишённым побочных эффектов, —
Лисп является типичным представителем семейства аппликативных языков программирования.
Изучение концепций, лежащих в его основе, без сомнения будет полезно для студентов и учёных-информатиков наших и будущих лет.
Основанные на идее _«функции»_ — идее, которая веками оттачивалась и уточнялась математикой, —
аппликативные языки присутствуют практически везде, где присутствуют вычисления,
и проявляют себя в различных формах: от перенаправления потоков в UNIX-системах
до языка расширений редактора Emacs.
Использование таких инструментов без понимания их центрального механизма — комбинации —
подобно попыткам выразить мысль с помощью отдельных слов вместо цельного предложения.

## Аудитория

Книга предназначена для широкой аудитории специалистов:

  - для выпускников вузов и студентов,
    которые изучают приёмы реализации языков программирования;
    аппликативных или нет, интерпретацию или компиляцию — не важно;

  - для программистов на Лиспе или Scheme,
    желающих чётче понимать нюансы и стоимость используемых ими конструкций,
    чтобы писать более эффективные и переносимые программы;

  - для всех любителей аппликативных языков,
    которые найдут в этой книге множество интересных размышлений на свою любимую тему.

## Философия

Данная книга основана на курсе лекций, читаемом в магистратуре Университета Пьера и Марии Кюри.
Некоторые части курса также преподаются в Политехнической школе.

Рассматриваемые темы обычно следуют за вводным курсом аппликативных
языков вроде Лиспа, Scheme или ML, так как подобные курсы чаще всего
заканчиваются детальным разбором рассматриваемого языка.
Цель этой книги — как можно шире покрыть тему семантики аппликативных языков,
а также разработки их интерпретаторов и компиляторов.
Здесь приведено двенадцать интерпретаторов и два компилятора (в байт-код и в Си).
Не обходится стороной и объектно-ориентированная модель
(рассматриваемая на примере <span class="sc">Meroon</span>).
Также, в отличие от многих других книг, мы не пренебрегаем такими существенными для семейства Лиспов вопросами
как рефлексия, интроспекция, динамическая кодогенерация и, конечно же, макросы.

Отчасти эта книга вдохновлена двумя работами:
«Anatomy of Lisp» [[All78]](zz_bibliography.html#all78),
где разбираются подходы к реализации Лиспа в семидесятых годах,
и «Operating System Design: The Xinu Approach» [[Com84]](zz_bibliography.html#com84),
в которой исходный код операционной системы приводится без каких-либо сокращений,
что убеждает читателя в верности изложения.

В таком же духе — точности, а не лаконичности — написана и эта книга,
главным вопросом которой есть семантика аппликативных языков в общем и Scheme в частности.
Исследуя множество реализаций, рассматривая их различные аспекты,
мы узнаем с максимальной точностью, как строится любая подобная система.
Мы рассмотрим большую часть проблемных вопросов, вызывающих расколы в сообществе;
каждая из этих проблем будет изучена, варианты её решения — реализованы, сравнены и проанализированы.
В общем, у вас будут все карты на руках, чтобы имея такой фундамент знаний, вы могли самостоятельно экспериментировать с рассматриваемыми концепциями.

Естественно, полный исходный код всех программ, приведённых в этой книге, доступен в электронном виде.
Подробности [чуть ниже](#Исходный-код).

## Структура

Книга разделена на две части.
Первая часть начинается реализацией наивного интерпретатора Лиспа и рассматривает в основном семантику Scheme.
Здесь нас будет больше интересовать точность повествования,
поэтому мы будем раз за разом уточнять и переорпределять различными способами
пространства имён (Lisp<sub>1</sub>, Lisp<sub>2</sub> и т. д.),
продолжения (и связанные с ними управляющие конструкции),
присваивание и изменяемые структуры данных.
Мы заметим, что по мере того, как определяемый язык обрастает возможностями, его определение становится всё более простым, приближаясь к λ-исчислению.
Полученное таким образом описание языка мы превратим в его денотационный, строго математический эквивалент.

Более шести лет практики преподавания убедили меня в том, что именно такой подход постепенного уточнения языка необходим для мягкого знакомства с темой исследования языков вообще и денотационной семантикой вычислений в частности — темой, которую мы не можем себе позволить обойти стороной.

Вторая часть книги следует иным путём.
Преследуя цель сделать наивную реализацию денотационного интерпретатора более эффективной,
мы коснёмся темы ускорения интерпретации (заранее вычисляя неизменные величины),
а потом реализуем эту предварительную обработку (с помощью прекомпиляции) в виде компилятора в байт-код.
Здесь подготовка программы к исполнению и собственно исполнение чётко отделены,
поэтому в этой части будут рассматриваться такие темы как динамические вычисления (`eval`),
рефлексия (окружения как объекты первого класса, самоинтерпретация, «башня» интерпретаторов),
семантика макросов.
Под конец мы также реализуем транслятор Scheme в код на языке Си.

Завершается книга реализацией объектно-ориентированной системы,
которая существенно поможет нам в реализации некоторых интерпретаторов и компиляторов.

| Глава | Прототип                    |
| ----- | --------------------------- |
|   1   | `(eval exp env)`            |
|   2   | `(eval exp env fenv)`       |
|       | `(eval exp env fenv denv)`  |
|       | `(eval exp env denv)`       |
|   3   | `(eval exp env cont)`       |
|   4   | `(eval e r s k)`            |
|   5   | `((meaning e) r s k)`       |
|   6   | `((meaning e r) sr k)`      |
|       | `((meaning e r tail?) k)`   |
|       | `((meaning e r tail?))`     |
|   7   | `(run (meaning e r tail?))` |
|  10   | `(->C (meaning e r))`       |

<p class="caption">Прототипы интерпретаторов и компиляторов.</p>

Как известно, повторенье — мать ученья.
Все приведённые интерпретаторы намеренно написаны в различных стилях:
наивном, объектно-ориентированном, основанном на замыканиях, денотационном и т. д.
Это позволит рассмотреть множество приёмов, используемых при реализации аппликативных языков.
Также это подтолкнёт вас на размышления о различиях между ними.
Понимание этих различий является истинным пониманием языка и его реализаций.
Лисп — это не одна из таких реализаций,
это целое *семейство* диалектов, каждый из которых имеет свой уникальный набор черт, которые мы будем рассматривать.

Главы более-менее независимы, занимают примерно по 40 страниц.
Каждая глава имеет список упражнений, ответы к которым можно найти в конце книги.
Список литературы содержит не только исторически важные книги, позволяющие отследить развитие Лиспа с 1960 года, но и современные труды.

## Предварительные знания

Хоть я и надеюсь, что книга будет увлекательной и содержательной,
но она не обязательно будет лёгкой для чтения.
Некоторые описанные здесь вещи можно постичь только если прикладывать усилия,
соответствующие их сложности.
Говоря языком куртуазных романов,
некоторые предметы воздыханий открывают свою истинную красоту и обаяние только тогда,
когда мы учтиво, но непреклонно штурмуем их;
если их богатый и непростой внутренний мир не будет под постоянной осадой,
они так и останутся неприступными.

Изучение сущности языков программирования требует владения инструментами вроде λ-исчисления и денотационной семантики.
Хоть повествование и будет последовательно и логично переходить от одной темы к следующей,
это не сможет избавить вас ото всех необходимых усилий.

Вам потребуются некоторые предварительные знания о Лиспе или Scheme;
в частности, знание примерно тридцати базовых функций и умение понимать рекурсию без чрезмерного умственного напряжения.
Основным диалектом этой книги выбран Scheme,
краткий обзор которого можно найти [ниже](#Краткий-обзор-scheme).
Мы также будем использовать объектно-ориентированное расширение <span class="sc">Meroon</span>,
которое поможет нам в рассмотрении некоторых проблем представления и реализации структур данных.

Все приведённые в книге программы были протестированы и действительно работают в интерпретаторе Scheme.
А для тех, кто усвоит материал этой книги, не будет составлять особого труда портировать их куда угодно!

## Благодарности

Я должен поблагодарить организации, которые обеспечили меня оборудованием
(Apple Mac SE/30, затем Sony NEWS 3260, впоследствии разнообразными PC и PowerBook)
и вообще сделали эту книгу возможной:
Политехническую школу,
Государственный институт исследований в области информатики и автоматики (INRIA),
Национальный центр научных исследований (CNRS).

Также я хотел бы поблагодарить тех, кто помогал мне всем, чем мог, в создании
этой книги.
В особом долгу я перед Софи Англад, Жози Барон, Кэтлин Коллэвей,
Жеромом Шейёксом, Марком Филе, Жаном-Мари Жеффруа, Кристианом Жюльеном,
Жан-Жаком Лакрампом, Мишелем Леметром, Люком Моро, Жаном-Франсуа Перро,
Дэниелом Риббенсом, Бернардом Серпеттом, Мануэлем Серрано, Пьером Ве,
а также перед моей музой, Клэр Н.[^1]

Конечно же, все ошибки, которые, к сожалению, неизбежно присутствуют в тексте,
являются моими собственными.

[^1]: Sophie Anglade, Josy Baron, Kathleen Callaway, Jérôme Chailloux, Marc Feeley,
      Jean-Marie Geffroy, Christian Jullien, Jean-Jacques Lacrampe, Michel Lemaître,
      Luc Moreau, Jean-François Perrot, Daniel Ribbens, Bernard Serpette,
      Manuel Serrano, Pierre Weis, Claire N. — *Прим. перев.*

## Нотация

Фрагменты программ будут набраны <tt>шрифтом, который несомненно напомнит вам о старых добрых пишущих машинках</tt>.
Некоторые слова в коде также могут быть набраны _курсивом_ для обозначения понятий, подразумеваемых на месте этих слов.

<a id="indexC:→"></a>
<a id="indexC:≡"></a>
Знак → читается: «принимает значение», а знак ≡ обозначает эквивалентность, «то же самое, что и».
При разборе вычисления выражений после вертикальной черты мы будем записывать окружение, в котором проводятся вычисления.
Вот пример, иллюстрирующий эти соглашения:

```scheme
(let ((a (+ b 1)))
  (let ((f (lambda () a)))
    (foo (f) a) ) )│
                   │b → 3       ; значением переменной foo является функция cons,
                   │foo ≡ cons  ; создающая точечные пары

≡ (let ((f (lambda () a))) (foo (f) a))│
                                       │a → 4
                                       │b → 3
                                       │foo ≡ cons
                                       │f ≡ (lambda () a)│
                                                         │a → 4
≡ (foo (f) a)│
             │a → 4
             │b → 3
             │foo ≡ cons
             │f ≡ (lambda () a)│
                               │a → 4
→ (4 . 4)
```

Все имена переменных и сообщения об ошибках в приводимых программах мы будем записывать на английском — «родном языке» Scheme.

Мы будем использовать несколько нестандартных функций вроде `gensym`,
которая генерирует символы, гарантированно не встречавшиеся ранее в тексте программы.
В десятой главе также будут применяться функции `format` и `pp` для форматированного вывода (pretty-printing).
Эти функции присутствуют в большинстве реализаций Лиспа и Scheme.

Некоторые выражения имеют смысл только для какого‑то из диалектов Лиспа вроде
<span class="sc">Common Lisp</span>,
Dylan,
<span class="sc">EuLisp</span>,
IS-Lisp, Le-Lisp, Scheme и т. д.
В этом случае мы будем писать рядом название диалекта:

```lisp
(defdynamic fooncall            ;; IS-Lisp
  (lambda (one :rest others)
    (funcall one others) ) )
```

Мы будем использовать гиперссылки, например, чтобы указать [на упражнение](ch01_basics.html#Упражнение-1.1).
Также в книге есть [предметный указатель](zz_index.html) со ссылками на все определяемые функции.

## Краткий обзор Scheme

Для изучения Scheme существует множество отличных книг,
вроде [[AS85]](zz_bibliography.html#as85),
[[Dyb87]](zz_bibliography.html#dyb87),
[[SF89]](zz_bibliography.html#sf89).
Мы же будем опираться на спецификацию, описанную в документе «Revised revised revised revised revised Report on Scheme»,
название которого часто сокращают до R<sup>5</sup>RS. [[KCR98]](zz_bibliography.html#kcr98)

Сейчас мы лишь набросаем основные характерные черты этого диалекта;
те черты, которые потом будут подробно проанализированы по мере улучшения понимания языка.

В Scheme можно использовать символы, знаки[^2], строки, списки, числа, логические значения, векторы, функции (или процедуры, как их принято называть в Scheme).

[^2]: Если возможны разночтения, то слово _знак_ будет использоваться
      в смысле «печатный символ» (character), а слово _символ_ —
      в привычном для Лиспа значении (symbol). — *Прим. перев.*

Каждый из этих типов данных имеет соответствующий предикат:
`symbol?`, `char?`, `string?`, `pair?`, `number?`, `boolean?`, `vector?`, `procedure?`.

Помимо них в наличии есть процедуры-аксессоры и модификаторы для тех типов,
где это имеет смысл: `string-ref`, `string-set!`, `vector-ref` и `vector-set!`.

Для списков они называются `car`, `cdr`, `set-car!` и `set-cdr!`.

Функции `car` и `cdr` могут комбинироваться.
Например, для доступа ко второму элементу списка используется `cadr`.

Все значения этих типов могут быть непосредственно записаны в программе.
С символами и числами всё очевидно.
Перед знаками пишется префикс `#\`, например: `#\Z`, `#\+`, `#\space`.
Строки окружаются `"кавычками"`, списки — `(круглыми скобками)`.
Логические значения записываются как `#t` и `#f` соответственно.
Для записи векторов используется синтаксис `#(do re mi)`.
Естественно, такие значения могут быть построены и динамически
с помощью `cons`, `list`, `string`, `make-string`, `vector`, `make-vector`.
Также в наличии есть функции приведения типов вроде `string->symbol` и `integer->char`.

Ввод-вывод обеспечивают следующие функции: `read` читает вводимые выражения,
`display` выводит их на экран, а `newline` переходит на следующую строку.

<br/>

<a id="indexR:форма!концепция Scheme"></a>
Программы на Scheme представляются так называемыми _формами_.

<a id="indexC:begin"></a>
Форма `begin` позволяет сгруппировать формы и вычислить их последовательно;
например, `(begin (display 1) (display 2) (newline))`.

<a id="indexC:if"></a><a id="indexC:cond"></a><a id="indexC:else"></a>
<a id="indexE:Scheme!логические значения"></a>
<a id="indexR:логические значения!в Scheme"></a>
Есть несколько форм ветвления.
Простейшей из них является *if–then–else*,
которая на Scheme так и записывается:
<code>(if <em>условие</em> <em>тогда</em> <em>иначе</em>)</code>.
Для выбора из большего числа вариантов в Scheme есть формы `cond` и `case`.
Форма `cond` содержит список утверждений,
каждое из которых начинается с условия — выражения, возвращающего логическое значение, —
за которым располагается последовательность других форм (следствие).
Условия вычисляются последовательно до тех пор, пока одно из них не вернёт истину (а точнее: не ложь, не `#f`).
Затем вычисляется следствие данного утверждения и результат его вычисления становится
результатом всей формы `cond`.
Вот пример использования этой формы, который заодно показывает ключевое слово `else`:

```scheme
(cond ((eq? x 'flip) 'flop)
      ((eq? x 'flop) 'flip)
      (else (list x "neither flip nor flop")) )
```

<a id="indexC:case"></a>
Форма `case` похожа на `cond`, но она принимает первым параметром форму, на основе значения которой производится выбор между вариантами.
Каждый из вариантов описывается набором возможных значений.
Как только найден подходящий вариант, он вычисляется и это становится результатом всей формы `case`.
Аналогично, в конце может стоять универсальный вариант `else`.
Вот так можно переписать предыдущий пример с помощью `case`:

```scheme
(case x
  ((flip) 'flop)
  ((flop) 'flip)
  (else (list x "neither flip nor flop")) )
```

<a id="indexC:lambda"></a>
<a id="indexC:let"></a>
<a id="indexC:let*"></a>
<a id="indexC:letrec"></a>
<a id="indexC:set!"></a>
<a id="indexC:quote"></a>
Функции определяются формой `lambda`.
За словом `lambda` следует список аргументов,
а после него — последовательность выражений, которые описывают собственно вычисление функции.
Формы `let`, `let*` и `letrec` определяют локальные переменные
(они отличаются тонкостями инициализации).
Значения переменных в дальнейшем можно изменять с помощью формы `set!`.
Для записи литералов используется форма `quote`.

<a id="indexC:define"></a>
<a id="indexC:define!синтаксис"></a>
<a id="indexR:синтаксис!define@\protect`define`"></a>
С помощью формы `define` можно назначить имя любому значению.
Она также позволяет определять локальные переменные
и предоставляет специальный синтаксис удобной записи функций.
Вот, что имеется ввиду:

```scheme
(define (rev l)
  (define nil '())
  (define (reverse l r)
    (if (pair? l)
        (reverse (cdr l) (cons (car l) r))
        r ) )
  (reverse l nil) )
```

Без синтаксического сахара этот пример выглядит так:

```scheme
(define rev
  (lambda (l)
    (letrec ((reverse (lambda (l r)
                        (if (pair? l)
                            (reverse (cdr l) (cons (car l) r))
                            r ) )))
      (reverse l '()) ) ) )
```

На этом мы заканчиваем наш краткий обзор Scheme.

## Исходный код

Программы (интерпретируемые и скомпилированные), приведённые в этой книге,
объектную систему и тесты для них можно забрать по следующему адресу:

> [https://github.com/ilammy/lisp/blob/master/scm-src.zip](https://github.com/ilammy/lisp/blob/master/scm-src.zip)

Электронный адрес автора книги:
[Christian.Queinnec@lip6.fr](mailto:Christian.Queinnec@lip6.fr)

## Рекомендуемая литература

Так как подразумевается, что вы уже знаете Scheme, мы будем ссылаться на
традиционные [[AS85]](zz_bibliography.html#as85), [[SF89]](zz_bibliography.html#sf89).

Чтобы получить от книги больше, имеет смысл поглядывать в другие руководства:
<span class="sc">Common Lisp</span> [[Ste90]](zz_bibliography.html#ste90),
Dylan [[App92b]](zz_bibliography.html#app92b),
<span class="sc">EuLisp</span> [[PE92]](zz_bibliography.html#pe92),
IS-Lisp [[ISO94]](zz_bibliography.html#iso94),
Le-Lisp [[CDD<sup>+</sup>91]](zz_bibliography.html#cdd+91),
Oaklisp [[LP88]](zz_bibliography.html#lp88),
Scheme [[KCR98]](zz_bibliography.html#kcr98),
T [[RAM84]](zz_bibliography.html#ram84),
Talk [[ILO94]](zz_bibliography.html#ilo94).

Наконец, для лучшего понимания языков программирования в целом будет полезной
книга [[BG94]](zz_bibliography.html#bg94).[^3]

[^3]: Кроме того, лично я хотел бы посоветовать замечательную книгу
      *Franklyn Turbak and David Gifford with Mark A. Sheldon.*
      Design Concepts in Programming Languages. —
      The MIT Press, 2008. — *Прим. перев.*
