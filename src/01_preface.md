# К читателю

Несмотря на то, что литературы на тему Лиспа существует достаточно много
и она вполне доступна для понимания, эта книга имеет свою нишу.
Программирование требует владения фундаментальными основами языка.
Для Лиспа и Scheme ими являются нетривиальные вещи вроде функций высшего порядка,
объектов, продолжений и тому подобного.
Их незнание и непонимание преграждает вам путь в будущее,
так как то, что ещё сегодня считалось продвинутым знанием,
завтра уже станет нормой для образованного человека.

Мы собираемся в деталях прояснить природу данных сущностей, их истоки и разновидности.
Ходит поговорка, что лисперы знают ценность каждого выражания в программе, но не ведают их цены.
Поэтому мы также постараемся сократить эту пропасть в понимании языка с помощью детального изучения его семантики,
а также реализации различных возможностей Лиспа, которые были изобретены за его
более чем тридцатилетнюю историю.

Лисп — это приятный язык программирования,
на котором многие фундаментальные и сложные вещи выражаются простым образом.
Вместе с ML — своим строго типизированным собратом, (почти) лишённым побочных эффектов, —
Лисп является типичным представителем семейства аппликативных языков программирования.
Изучение концепций, лежащих в его основе, без сомнения будет полезно для студентов и учёных-информатиков наших и будущих лет.
Основанные на идее _«функции»_ — идее, которая веками оттачивалась и уточнялась математикой, —
аппликативные языки присутствуют практически везде, где присутствуют вычисления,
и проявляют себя в различных формах: от перенаправления потоков в UNIX-системах
до языка расширений редактора Emacs.
Использование таких инструментов без понимания их центрального механизма — комбинации —
подобно попыткам выразить мысль с помощью отдельных слов вместо цельного предложения.

## Аудитория

Книга предназначена для широкой аудитории специалистов:

  - для выпускников вузов и студентов,
    которые изучают приёмы реализации языков программирования;
    аппликативных или нет, интерпретацию или компиляцию — не важно;

  - для программистов на Лиспе или Scheme,
    желающих чётче понимать нюансы и стоимость используемых ими конструкций,
    чтобы писать более эффективные и переносимые программы;

  - для всех любителей аппликативных языков,
    которые найдут в этой книге множество интересных размышлений на свою любимую тему.

## Философия

Данная книга основана на курсе лекций, читаемом в магистратуре Университета Пьера и Марии Кюри.
Некоторые части курса также преподаются в Политехнической школе.

Рассматриваемые темы обычно следуют за вводным курсом аппликативных
языков вроде Лиспа, Scheme или ML, так как подобные курсы чаще всего
заканчиваются детальным разбором рассматриваемого языка.
Цель этой книги — как можно шире покрыть тему семантики аппликативных языков,
а также разработки их интерпретаторов и компиляторов.
Здесь приведено двенадцать интерпретаторов и два компилятора (в байт-код и в Си).
Не обходится стороной и объектно-ориентированная модель
(рассматриваемая на примере <span style="font-variant: small-caps;">Meroon</span>).
Также, в отличие от многих других книг, мы не пренебрегаем такими существенными для семейства Лиспов вопросами
как рефлексия, интроспекция, динамическая кодогенерация и, конечно же, макросы.

Отчасти эта книга вдохновлена двумя работами:
«Anatomy of Lisp» [[All78]](zz_bibliography.html#all78),
где разбираются подходы к реализации Лиспа в семидесятых годах,
и «Operating System Design: The Xinu Approach» [[Com84]](zz_bibliography.html#com84),
в которой исходный код операционной системы приводится без каких-либо сокращений,
что убеждает читателя в верности изложения.

В таком же духе — точности, а не лаконичности — написана и эта книга,
главным вопросом которой есть семантика аппликативных языков в общем и Scheme в частности.
Исследуя множество реализаций, рассматривая их различные аспекты,
мы узнаем с максимальной точностью, как строится любая подобная система.
Мы рассмотрим большую часть проблемных вопросов, вызывающих расколы в сообществе;
каждая из этих проблем будет изучена, варианты её решения — реализованы, сравнены и проанализированы.
В общем, у вас будут все карты на руках, чтобы имея такой фундамент знаний, вы могли самостоятельно экспериментировать с рассматриваемыми концепциями.

Естественно, полный исходный код всех программ, приведённых в этой книге, доступен в электронном виде.
Подробности [чуть ниже](#Исходный-код).

<a id="pref/sect:structure"></a>
## Структура

Книга разделена на две части.
Первая часть начинается реализацией наивного
интерпретатора Лиспа и рассматривает в основном семантику Scheme.
Здесь нам
требуется точность повествования, поэтому мы будем раз за разом уточнять и
переопределять различными способами пространства имён (\Lisp1, \Lisp2 и т. д.),
продолжения (и связанные с ними управляющие конструкции), присваивание и
изменяемые структуры данных.
Мы заметим, что по мере того, как определяемый
язык обрастает возможностями, его определение становится всё более простым,
приближаясь к $\lambda$-исчислению.
Полученное таким образом описание языка мы
превратим в его денотационный, строго математический эквивалент.

Более шести лет практики преподавания убедили меня в том, что именно такой
подход постепенного уточнения языка необходим для мягкого знакомства с темой
исследования языков вообще и денотационной семантикой вычислений в частности
 — темой, которую мы не можем себе позволить обойти стороной.

Вторая часть книги следует иным путём.
Преследуя цель сделать наивную
реализацию денотационного интерпретатора более эффективной, мы коснёмся темы
ускорения интерпретации (заранее вычисляя неизменные величины), а потом
реализуем эту предварительную обработку (с помощью прекомпиляции) для нашего
компилятора в байт-код.
В этой части подготовка программы к исполнению и
собственно исполнение чётко отделены, поэтому здесь будут рассматриваться такие
темы как динамические вычисления (`eval`), рефлексия (окружения как объекты
первого класса, самоинтерпретация, «башня» интерпретаторов), семантика
макросов.
Далее мы реализуем транслятор Scheme в код на языке Си.

Завершается книга реализацией объектно-ориентированной системы, которая
существенно поможет нам в реализации некоторых интерпретаторов и компиляторов.

Как известно, повторенье — мать ученья.
Все приведённые интерпретаторы
намеренно написаны в различных стилях: наивном, объектно-ориентированном,
основанном на замыканиях, денотационном и т. д.
Это позволит рассмотреть
множество приёмов, используемых при реализации аппликативных языков.
Также это
подтолкнёт вас на размышления о различиях между ними.
Понимание этих различий
(см. таблицу \ref{pref/table:signatures} с подсказками) является истинным
пониманием языка и его реализаций.
Лисп — это не одна из таких реализаций,
это *семейство* диалектов, каждый из которых имеет свой уникальный набор
черт, которые мы будем рассматривать.

\begin{table}
\begin{center}\begin{tabular}{cl}
Глава & Прототип                    \\
\hline
1  & `(eval exp env)`            \\
2  & `(eval exp env fenv)`       \\
   & `(eval exp env fenv denv)`  \\
   & `(eval exp env denv)`       \\
3  & `(eval exp env cont)`       \\
4  & `(eval e r s k)`            \\
5  & `((meaning e) r s k)`       \\
6  & `((meaning e r) sr k)`      \\
   & `((meaning e r tail?) k)`   \\
   & `((meaning e r tail?))`     \\
7  & `(run (meaning e r tail?))` \\
10 & `(->C (meaning e r))`
\end{tabular}\end{center}
\caption{Прототипы интерпретаторов и компиляторов.}
\label{pref/table:signatures}
\end{table}

Главы более-менее независимы, занимают примерно по 40 страниц; каждая глава
имеет список упражнений, ответы к которым можно найти в конце книги.
Список
литературы содержит не только исторически важные книги, позволяющие отследить
развитие Лиспа с 1960 года, но и современные труды.


<a id="pref/sect:prereqs"></a>
## Предварительные знания

Хоть я и надеюсь, что книга будет увлекательной и содержательной, но она
не обязательно будет лёгкой для чтения.
Некоторые описанные здесь вещи можно
постичь, только если прикладывать усилия, соответствующие их сложности.
Говоря
языком куртуазных романов, некоторые предметы воздыханий открывают свою истинную
красоту и обаяние только тогда, когда мы учтиво, но непреклонно штурмуем их;
если их богатый и непростой внутренний мир не будет под постоянной осадой, они
так и останутся неприступными.

Изучение сущности языков программирования требует владения инструментами вроде
$\lambda$-исчисления и денотационной семантики.
Хотя повествование и будет
мягко, последовательно и логично переходить от одной темы к следующей, это
не сможет избавить вас ото всех необходимых усилий.

Вам потребуются некоторые предварительные знания о Лиспе или Scheme;
в частности, знание примерно тридцати базовых функций и умение понимать рекурсию
без чрезмерного умственного напряжения.
Основным языком этой книги выбран Scheme
(его краткий обзор можно найти на странице [pref/sect:scheme-summary](xxx_appropriate.html#pref/sect:scheme-summary)),
а также его объектно-ориентированное расширение \Meroon.
Данное расширение
поможет нам в рассмотрении некоторых проблем представления и реализации структур
данных.

Все приведённые в книге программы были протестированы и действительно работают
в интерпретаторе Scheme.
А для тех, кто усвоит материал этой книги, не будет
составлять особого труда портировать их куда угодно!


<a id="pref/sect:thanks"></a>
## Благодарности

Я должен поблагодарить организации, которые обеспечили меня оборудованием
(Apple Mac SE/30, затем Sony NEWS 3260, впоследствии разнообразными PC и
PowerBook) и вообще сделали эту книгу возможной: Политехническую школу,
Государственный институт исследований в области информатики и автоматики
(INRIA\kern-0.1em), Национальный центр научных исследований (CNRS).

Также я хотел бы поблагодарить тех, кто помогал мне всем, чем мог, в создании
этой книги.
В особом долгу я перед Софи Англад, Жози Бирон, Кэтлин Коллэвей,
Жеромом Шейёксом, Жаном-Мари Жеффруа, Кристианом Жюльеном, Жан-Жаком Лакрампом,
Мишелем Леметром, Люком Моро, Жаном-Франсуа Перро, Дэниелом Риббенсом,
Бернардом Серпеттом, Мануэлем Серрано, Пьером Ве, а также перед моей музой,
Клэр Н.{\fnstyle{\RaggedRight}\trnote*{Sophie Anglade, Josy Byron, Kathleen
Callaway, J\'er\^ome Chaillox, Jean-Marie Geffroy, Christian Jullien,
Jean-Jacques Lacrampe, Michel Lema{\^\i}tre, Luc Moreau, Jean-Fran\c cois
Perrot, Daniel Ribbens, Bernard Serpette, Manuel Serrano, Pierre Weis,
Claire N. — *Прим. перев.*}}

Конечно же, все ошибки, которые, к сожалению, неизбежно присутствуют в тексте,
являются моими собственными.


<a id="pref/sect:notation"></a>
## Нотация

Фрагменты программ будут набраны \textcd{таким шрифтом, который несомненно
напомнит вам о старых добрых печатных машинках}.
Некоторые слова в коде также
будут набраны *курсивом* для обозначения понятий, подразумеваемых на
месте этих слов.

<a id="indexC:.->"></a>
<a id="indexC:.="></a>
Знак {\is} читается: «имеет значение», а знак {\equals} обозначает
эквивалентность, «имеет то же значение, что и».
При разборе вычисления
выражений после вертикальной черты мы будем записывать окружение, в котором
проводятся вычисления.
Вот пример, иллюстрирующий эти соглашения:

```scheme
(let ((a (+ b 1)))
  (let ((f (lambda () a)))
    (foo (f) a) ) )|\begin{where}
                    \- b {\is} 3
                    \- foo {\eq} cons
                    \end{where}|

|\eq| (let ((f (lambda () a))) (foo (f) a))|\begin{where}
                                            \- a {\is} 4
                                            \- b {\is} 3
                                            \- foo {\eq} cons
                                            \- f {\eq} (lambda () a)\begin{where}
                                                                   \- a {\is} 4
                                                                   \end{where}
                                            \end{where}|
|\eq| (foo (f) a)|\begin{where}
                  \- a {\is} 4
                  \- b {\is} 3
                  \- foo {\eq} cons
                  \- f {\eq} (lambda () a)\begin{where}
                                         \- a {\is} 4
                                         \end{where}
                  \end{where}|
|\is| (4 .
4)
```

Все имена переменных и сообщения об ошибках в приводимых программах мы будем
записывать на английском — «родном языке» Scheme.

Мы будем использовать несколько нестандартных функций вроде `gensym`, которая
генерирует символы, гарантированно не встречавшиеся ранее в тексте программы.
В десятой главе также будут применяться функции `format` и `pp` для
форматированного вывода (pretty-printing).
Эти функции есть в большинстве
реализаций Лиспа и Scheme.

Некоторые выражения имеют смысл только для какого‑то из диалектов Лиспа вроде
\CommonLisp, Dylan, \EuLisp, \ISLisp, \LeLisp,\footnote*{{\LeLisp} является
торговой маркой INRIA.} Scheme и т. д.
В этом случае мы будем писать рядом
название диалекта:

```scheme
(defdynamic fooncall          |\dialect{\ISLisp}|
  (lambda (one :rest others)
    (funcall one others) ) )
```

Дабы было легче ориентироваться в этой книге, мы будем использовать
обозначение {\seePage*} для перекрёстных ссылок на страницы.
Похожая нотация
будет использоваться при необходимости указать на упражнение: {\seeEx*}.
Также
в книге есть предметный указатель со ссылками на все определяемые функции.
\seePage[chapter:index]


<a id="pref/sect:scheme-summary"></a>
## Краткий обзор Scheme

Для изучения Scheme существует множество отличных книг, вроде [[as85]](zz_bibliography.html#as85),
[[dyb87]](zz_bibliography.html#dyb87), [[sf89]](zz_bibliography.html#sf89).
Мы же будем опираться на спецификацию, описанную
в документе «Revised revised revised revised revised Report on Scheme»,
название которого часто сокращают до \RnRS. [[kcr98]](zz_bibliography.html#kcr98)

Сейчас мы лишь набросаем основные характерные черты этого диалекта; те черты,
которые потом будут подробно проанализированы по мере улучшения понимания языка.

В Scheme можно использовать символы, знаки,\trnote*{Если возможны разночтения,
то слово _знак_ будет использоваться в смысле «печатный символ»
(character), а слово _символ_ — в привычном для Лиспа значении
(symbol). — *Прим. перев.*} строки, списки, числа, логические значения,
векторы, порты и функции (или процедуры, как их принято называть в Scheme).

Каждый из этих типов данных имеет соответствующий предикат: `symbol?`,
`char?`, `string?`, `pair?`, `number?`, `boolean?`, `vector?`,
`procedure?`.

Помимо них в наличии есть процедуры-аксессоры и модификаторы для тех типов,
где это имеет смысл: `string-ref`, `string-set!`, `vector-ref`
и `vector-set!`.

Для списков они называются `car`, `cdr`, `set-car!` и `set-cdr!`.

Функции `car` и `cdr` могут комбинироваться.
Например, для доступа
ко второму элементу списка используется `cadr`.

Все значения этих типов могут быть непосредственно записаны в программе.
С символами и числами всё очевидно.
Перед знаками пишется префикс
`\#\bslash`, например: `\#\bslash Z`, `\#\bslash +`,
`\#\bslash space`.
Строки окружаются `"`кавычками`"`, списки "---
`(`круглыми скобками`)`.
Логические значения записываются как `\#t`
и `\#f` соответственно.
Для записи векторов используется синтаксис
`\#(do re mi)`.
Естественно, такие значения могут быть построены и
динамически с помощью `cons`, `list`, `string`, `make-string`,
`vector`, `make-vector`.
Также в наличии есть функции приведения типов
вроде `string->symbol` и `int->char`.

Ввод-вывод обеспечивают следующие функции: `read` читает вводимые выражения,
`display` выводит их на экран, а `newline` переходит на следующую строку.

\bigskip

<a id="indexR:форма!концепция Scheme"></a>
Программы на Scheme представляются так называемыми _формами_.

<a id="indexC:begin"></a>
Форма `begin` позволяет сгруппировать формы и вычислить их последовательно;
например, `(begin (display 1) (display 2) (newline))`.

<a id="indexC:if"></a><a id="indexC:cond"></a><a id="indexC:else"></a>
<a id="indexE:Scheme!логические значения"></a>
<a id="indexR:логические значения!в Scheme"></a>
Есть несколько форм ветвления.
Простейшей из них является *if--then--else*,
которая на Scheme так и записывается: \ic{(if *условие* *тогда*
*иначе*)}.
Если вариантов больше двух, то для этого случая в Scheme есть
формы `cond` и `case`.
Форма `cond` содержит список утверждений, каждое
из которых начинается с условия — выражения, возвращающего логическое
значение, — за которым располагается последовательность других форм
(следствие).
Она последовательно вычисляет условия утверждений до тех пор,
пока одно из них не вернёт истину (а точнее: не ложь, не `\#f`); затем
вычисляется следствие данного утверждения, и результат его вычисления становится
результатом всей формы `cond`.
Вот пример использования этой формы, который
заодно показывает ключевое слово `else`:

```scheme
(cond ((eq? x 'flip) 'flop)
      ((eq? x 'flop) 'flip)
      (else (list x "neither flip nor flop")) )
```

<a id="indexC:case"></a>
Форма `case` похожа на `cond`, но она принимает первым параметром форму,
на основе значения которой производится выбор между вариантами.
Каждый из
вариантов в начале содержит список значений, которые подходят для него.
Как
только найден подходящий вариант, он вычисляется и этот результат становится
результатом всей формы `case`.
Аналогично, в конце может стоять универсальный
вариант `else`.
Вот так можно переписать предыдущий пример
с помощью `case`:

```scheme
(case x
  ((flip) 'flop)
  ((flop) 'flip)
  (else (list x "neither flip nor flop")) )
```

<a id="indexC:lambda"></a>
<a id="indexC:let"></a><a id="indexC:let*"></a><a id="indexC:letrec"></a>
<a id="indexC:set"!"></a><a id="indexC:quote"></a>
Функции определяются формой `lambda`.
За словом `lambda` следует список
аргументов, а после него — последовательность выражений, которые описывают
собственно вычисление функции.
Формы `let`, `let*` и `letrec`
определяют локальные переменные (они отличаются тонкостями вычисления начальных
значений определяемых переменных).
Значения переменных в дальнейшем можно
изменять с помощью формы `set!`.
Для записи литералов используется
форма `quote`.

<a id="indexC:define"></a>
<a id="indexC:define!синтаксис"></a>
<a id="indexR:синтаксис!define@\protect`define`"></a>
С помощью формы `define` можно назначить имя любому значению.
У неё есть
особые возможности, которые мы будем использовать.
В частности, возможность
использовать её как подобие `let`, а также вариант синтаксиса этой формы,
позволяющий удобнее определять функции.
Вот, что имеется ввиду:

```scheme
(define (rev l)
  (define nil '())
  (define (reverse l r)
    (if (pair? l) (reverse (cdr l) (cons (car l) r)) r))
  (reverse l nil) )
```

\noindent Без синтаксического сахара этот пример выглядит так:

```scheme
(define rev
  (lambda (l)
    (letrec ((reverse (lambda (l r)
                        (if (pair? l) (reverse (cdr l)
                                               (cons (car l) r))
                            r) )))
      (reverse l '()) ) ) )
```

На этом мы заканчиваем наш краткий обзор Scheme.


<a id="pref/sect:source"></a>
## Исходный код

Программы (интерпретируемые и скомпилированные), приведённые в этой книге,
объектную систему и тесты для них можно забрать по следующему адресу:
\begin{quote}
\url{http://pagesperso-systeme.lip6.fr/Christian.Queinnec/Books/LiSP-2ndEdition-2006Dec11.tgz}
\end{quote}

Электронный адрес автора книги:
\href{mailto:Christian.Queinnec@lip6.fr}{\nolinkurl{Christian.Queinnec@lip6.fr}}


<a id="pref/sect:reading"></a>
## Рекомендуемая литература

Так как подразумевается, что вы уже знаете Scheme, мы будем ссылаться на
традиционные \cite{as85,sf89}.

Чтобы получить от книги больше, имеет смысл поглядывать в другие руководства:
\CommonLisp [[ste90]](zz_bibliography.html#ste90), Dylan [[app92b]](zz_bibliography.html#app92b), \EuLisp [[pe92]](zz_bibliography.html#pe92),
\ISLisp [[iso94]](zz_bibliography.html#iso94), \LeLisp \cite{cdd+91}, Oaklisp [[lp88]](zz_bibliography.html#lp88),
Scheme [[kcr98]](zz_bibliography.html#kcr98), T [[ram84]](zz_bibliography.html#ram84), Talk [[ilo94]](zz_bibliography.html#ilo94).

Наконец, для лучшего понимания языков программирования в целом будет полезной
книга [[bg94]](zz_bibliography.html#bg94).{\fnstyle{\RaggedRight}\trnote*{Кроме того, лично я хотел бы
посоветовать замечательную книгу \textit{Franklyn Turbak and David Gifford with
Mark A. Sheldon.} Design Concepts in Programming Languages. — The MIT Press,
2008. — 1352 p. — *Прим. перев.*}}
