# Вычисляем атомы

Одна из ключевых особенностей Лиспа состоит в том, что программы записываются теми же конструкциями, что и остальные данные.
Естественно, у любых данных есть определённый формат представления и программы не являются исключением.
Главные соглашения этого формата: переменные записываются символами (своими именами),
а вызовы функций — списками, где первый элемент — это вызываемая функция, а остальные — её аргументы.

<a id="indexR:атом"></a>
Как и любой другой компилятор,
`evaluate` начинает свою работу с синтаксического анализа переданного ей выражения, чтобы выяснить, что именно оно означает.
В этом смысле, название раздела не совсем правильное:
мы рассматриваем не буквально вычисление атомов, а интерпретацию программ, состоящих из атомов.
Сейчас важно отличать саму программу от её представления (письмо от листа бумаги, на котором оно написано).
Функция `evaluate` работает с представлением программ,
по нему она узнаёт предписываемые программой действия и в конечном итоге исполняет их.

<a id="indexC:atom?"></a>
```scheme
(define (evaluate exp env)
  (if (atom? exp)               ; (atom? exp) ≡ (not (pair? exp))
      ...
      (case (car exp)
        ...
        (else ...) ) ) )
```

Если выражение не является списком, то оно может быть символом, или числом, или строкой.
Если это всё же символ, то он представляет _переменную_, а её значение хранится в окружении:

```scheme
(define (evaluate exp env)
  (if (atom? exp)
      (if (symbol? exp) (lookup exp env) exp)
      (case (car exp)
        ...
        (else ...) ) ) )
```

Функция `lookup` (которая рассматривается подробнее [в своём разделе](/ch1/05_environment.html))
знает, как отыскать значение переменной в окружении.
Вот её прототип:

<a id="indexC:lookup"></a>
```scheme
(lookup variable environment) → value
```

<a id="indexR:переменные!связь с символами"></a>
<a id="indexR:символы!связь с переменными"></a>
Как видим, здесь происходит неявное преобразование символа в переменную.
Если быть более дотошным, тогда вместо `(lookup exp env)` надо записать что‑то вроде:

```scheme
... (lookup (symbol->variable exp) env) ...
```

<a id="indexR:приведение типов"></a>
<a id="indexR:объекты!второго класса"></a>
В таком случае мы явно говорим, что значение переменной `exp`,
то есть символ с именем переменной должен быть превращён в переменную.
Также это подчёркивает тот факт, что функция `symbol->variable`[^3] вовсе не переводит значение `exp` само в себя;
она превращает синтаксическую сущность (символ) в семантическую (переменную).
В действительности, переменные — это лишь воображаемые объекты,
которым язык и программист дали какие‑то имена, и которые ради удобства используются в форме имён.
Способ представления имён также выбран из соображений удобства, так как Лисп имеет базовый тип символов.
В данном случае `symbol->variable` ничего не делает,
хотя в других языках может применяться какая-нибудь другая форма записи имени переменной.
Например: если это строка, состоящая из знака доллара и имени переменной,
то конечно же `symbol->variable` будет уже не такой тривиальной.

[^3]: Лично я не люблю называть функции приведения типов `x‑>y`,
      потому что так сложнее понимать цепочки преобразований.
      Запись `(y‑>z(x‑>y ...))` не так очевидна, как `(z<‑y(y<‑x ...))`.
      Хотя, с другой стороны, одиночная запись `z<‑y` не так легко читается, как `y‑>z`.
      Приходится выбирать.

Если бы переменные действительно были лишь воображаемыми,
то `lookup` не знала бы как обрабатывать свой первый аргумент,
ведь она ожидает нечто «материальное».
Поэтому нам надо преобразовать переменную в её программное представление,
какой-нибудь уникальный ключ, по которому `lookup` сможет отыскать переменную в окружении.
Поэтому ещё точнее было бы записать:

```scheme
... (lookup (variable->key (symbol->variable exp)) env) ...
```

Однако, врождённая лень лисперов настаивает на использовании символов для ключей.
Так что `variable‑>key` — это лишь обратная функция к `symbol->variable`,
и их последовательное применение никак не изменяет `exp`.

<a id="indexR:автоцитирование"></a>
<a id="indexR:механизм автоцитирования"></a>
Если выражение атомарное (то есть не является списком) и не является символом,
то его обычно считают представлением какой-нибудь константы с соответствующим значением.
Такое поведение называется механизмом _автоцитирования_.
Автоцитируемый объект не требует явного цитирования и имеет собственное значение.
За примерами можно обратиться к [[Cha96]](zz_bibliography.html#cha96).

Но является ли такое поведение правильным?
Во-первых, атомарные объекты не обязательно обозначают сами себя.
Например, строка `"a?b:c"` могла бы означать вызов компилятора Си,
затем исполнение получившейся программы и подстановку возвращаемого ей значения вместо этой строки.

С другими объектами (вроде функций) вообще не понятно, как именно их *вычислять*.
К примеру, ясно, что значением переменной `car` является функция,
которую мы можем вызвать, чтобы получить левый элемент пары.
Но что является значением самой *функции car*?
Чаще всего попытки вычисления значения функции являются ошибками в программе.

<a id="indexC:()"></a><a id="indexR:пустой список, ()"></a>
Ещё один пример проблемного значения — пустой список `()`.
Судя по тому, что это список, он должен означать вызов функции.
Вот только в нём нет ни аргументов, ни самой функции.
Такая запись в Scheme запрещена и является синтаксической ошибкой.

Поэтому необходимо очень аккуратно анализировать программу и автоцитировать только те данные,
для которых это явно стоить делать, например: числа, строки, логические значения.
([См. далее](/ch01/04_evaluating_forms.html#Цитирование) про специальную форму `quote`.)
Так что мы записываем следующее:

```scheme
(define (evaluate exp env)
  (if (atom? exp)
      (cond ((symbol? exp) (lookup exp env))
            ((or (number? exp) (string? exp) (char? exp)
                 (boolean? exp) (vector? exp) )
             exp )
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )
```

<a id="indexR:ошибки!варианты обработки"></a>
<a id="indexC:wrong"></a>
В этом фрагменте кода показано, как обрабатываются ошибки в программе.
Большинство лисп-систем имеют свои собственные механизмы обработки исключительных ситуаций,
которые непросто сделать переносимыми.
В случае ошибки мы вызываем `wrong`[^4] и передаём ей первым аргументом строку.
В строке находится текстовое описание ошибки,
а следующие за ней аргументы несут дополнительную информацию о том, что вызвало проблему.
Системы с зачаточным механизмом обработки ошибок обычно в случае проблем
выдают какие‑то непонятные надписи вроде `"Bus error: core dumped"` и умирают.
Другие останавливают текущие вычисления и возвращаются к диалоговому режиму.
А третьи могут связывать с вычисляемым выражением специальный обработчик исключений,
который перехватит брошенный объект, описывающий ошибку,
и будет уже по нему решать, что делать дальше.
В некоторых случаях даже реализуется подобие экспертной системы,
которая анализирует ошибку, вызвавший её код и выдаёт пользователю варианты её исправления.
В общем, сложно сказать однозначно, что следует делать в случае ошибки.

[^4]: Заметьте, не *функцию* `wrong`.
      Варианты её реализации подробнее рассматриваются [в седьмой главе](/ch07/09_exceptions.html).
