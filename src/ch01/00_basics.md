# Глава 1. Основы интерпретации

В этой главе описывается базовый интерпретатор, идеи которого проходят красной нитью через большую часть этой книги.
Он намеренно сделан простым и более близким к Scheme, чем к Лиспу, фактически описывая Лисп в терминах Scheme.
В этой вводной главе мы рассмотрим следующие темы: суть интерпретации;
взаимосвязь функций `eval` и `apply`; свойства окружений и функций.
Короче говоря, мы начнём рассматривать здесь то, что будем изучать подробнее в следующих главах.
Пусть вас не отпугнёт пропасть незнания по обе стороны моста, которым мы пойдём.

Интерпретатор и его варианты будут написаны на Scheme без использования каких‑либо существенных особенностей данного диалекта.

В книгах по Лиспу редко когда отказываются от нарциссического соблазна описать Лисп с помощью Лиспа.
Начало традиции положило первое руководство по LISP 1.5 [[MAE<sup>+</sup>62]](zz_bibliography.html#mae+62),
и впоследствии такой подход широко распространился.
Вот лишь малая часть существующих примеров:
[[Rib69]](zz_bibliography.html#rib69), [[Gre77]](zz_bibliography.html#gre77),
[[Que82]](zz_bibliography.html#que82), [[Cay83]](zz_bibliography.html#cay83),
[[Cha80]](zz_bibliography.html#cha80), [[SJ93]](zz_bibliography.html#sj93),
[[Rey72]](zz_bibliography.html#rey72), [[Gor75]](zz_bibliography.html#gor75),
[[SS75]](zz_bibliography.html#ss75),   [[All78]](zz_bibliography.html#all78),
[[McC78b]](zz_bibliography.html#mcc78b), [[Lak80]](zz_bibliography.html#lak80),
[[Hen80]](zz_bibliography.html#hen80), [[BM82]](zz_bibliography.html#bm82),
[[Cli84]](zz_bibliography.html#cli84), [[FW84]](zz_bibliography.html#fw84),
[[dRS84]](zz_bibliography.html#drs84), [[AS85]](zz_bibliography.html#as85),
[[R3R86]](zz_bibliography.html#r3r86), [[Mas86]](zz_bibliography.html#mas86),
[[Dyb87]](zz_bibliography.html#dyb87), [[WH89]](zz_bibliography.html#wh89),
[[Kes88]](zz_bibliography.html#kes88), [[LF88]](zz_bibliography.html#lf88),
[[Dil88]](zz_bibliography.html#dil88), [[Kam90]](zz_bibliography.html#kam90).

Эти интерпретаторы довольно сильно разнятся: как языками, которые они реализуют и используют для реализации,
так и — что более важно — целями, которые они преследуют.
Например, интерпретатор из [[Lak80]](zz_bibliography.html#lak80) показывает,
как объекты и концепции компьютерной графики естественным образом реализуются на Лиспе;
в то время как интерпретатор, описываемый в [[BM82]](zz_bibliography.html#bm82),
создан для замера сложности интерпретируемых программ.

<a id="indexR:язык!реализации"></a>
<a id="indexR:язык!реализуемый"></a>
Язык, *используемый* для реализации, тоже играет немалую роль.
Если в нём есть присваивание и доступ к памяти (`set-car!` и `set-cdr!`),
это даёт бо́льшую свободу и делает исходный код интерпретатора более компактным.
Мы получаем возможность описать язык в терминах, которые близки к машинным инструкциям.
Конечно, это усложняет составление описания, но в то же время уменьшает риск семантических расхождений.
Даже если подобное описание занимает больше места, чем высокоуровневое,
оно даёт более точное понимание смысла происходящего при интерпретации — для нас важно именно это.

\input{figures/fig1.1}
<p class="caption">Уровни сложности.</p>

На рисунке показано сравнение уровней сложности определяющего (по оси *x*)
и определяемого (по оси *y*) языков для некоторых из интерпретаторов.
Здесь хорошо виден ход развития наших знаний со временем:
всё более сложные задачи решаются с использованием всё более ограниченных возможностей.
Эта книга соответствует вектору, который начинается использованием
высокоуровневого Лиспа для реализации Scheme, а заканчивается реализацией
высокоуровневого Лиспа с помощью одного лишь λ-исчисления.
