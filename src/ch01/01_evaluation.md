# Вычисления

<a id="indexC:eval"></a>
<a id="indexR:вычислитель"></a>
Важнейшая часть интерпретатора Лиспа содержится в одной функции, вокруг которой крутится все остальное.
Эта функция, называемая `eval`, принимает на вход программу, а на выходе даёт результат её исполнения.
Явное наличие исполнителя кода отнюдь не случайно, а наоборот, является характерной и намеренно реализованной чертой Лиспа.

<a id="indexR:язык!универсальный"></a>
<a id="indexR:универсальный язык"></a>
<a id="indexR:машина Тьюринга"></a><a id="indexR:Тьюринга, машина"></a>
Язык программирования называется _универсальным_, если он не уступает в выразительных возможностях машине Тьюринга.
Так как машина Тьюринга довольно примитивна, то несложно разработать язык, который бы удовлетворял этому условию.
Действительно, наверное сложнее будет придумать полезный язык, который бы при этом не оказался полным по Тьюрингу.

<a id="indexR:тезис Чёрча"></a><a id="indexR:Чёрча, тезис"></a>
В соответствии с тезисом Чёрча, любая вычислимая функция может быть записана на любом тьюринг-полном языке.
Интерпретатор Лиспа можно представить как такую функцию, которая принимает программы и возвращает результаты их исполнения.
Так что если такая функция вообще существует, её можно записать на любом тьюринг-полном языке.
Следовательно, функцию-вычислитель Лиспа `eval` можно записать в частности на том же самом Лиспе.
В этом нет никаких противоречий: точно так же, к примеру, можно реализовать Фортран на Фортране.

Но что делает Лисп уникальным (и делает `eval` интересной), так это небольшой размер интерпретатора:
обычно от одной до двадцати страниц кода, в зависимости от детализации.[^1]
Таков результат желания сделать язык последовательным, с минимальным количеством исключений из правил,
и, что самое главное, с простым, но выразительным синтаксисом.

[^1]: Интерпретатор, описываемый в этой главе, занимает около 150 строк.

<a id="indexC:eval!свойства"></a>
Сам факт существования `eval`, а также возможность её описания на Лиспе имеют несколько интересных следствий.

  - Можно изучить Лисп или прочитав руководство по языку (в котором описываются все доступные возможности),
    или непосредственно изучив функцию `eval`.
    Второй подход сложен тем, что надо уже знать Лисп для того, чтобы понять описание `eval` —
    но ведь знание Лиспа по идее должно быть *следствием* изучения `eval`, нежели *предпосылкой* для него.
    На самом деле, достаточно знать лишь ту часть Лиспа, которая используется для описания `eval`.
    Кроме того, язык, определяемый одной `eval`, не является всем Лиспом:
    он есть лишь сутью языка, где реализованы только специальные формы и немного примитивных функций.

    Тем не менее, несомненно преимущество Лиспа в наличии возможности изучать язык двумя разными, но всё же связанными путями.

  - Тот факт, что `eval` написана на Лиспе, значит также и то, что
    среда разработки является составной частью языка и не требует значительных накладных расходов.
    Под средой разработки понимаются такие вещи как отладчик, трассировщик
    или даже возможность обратного хода [[Lie87]](zz_bibliography.html#lie87).
    Практически, реализация таких инструментов — это лишь доработка `eval`,
    к примеру, чтобы она выводила сообщения при вызове функций,
    приостанавливала вычисления в интересующих местах и так далее.

    Долгое время среда разработки с такими возможностями была уникальной для Лиспа.
    Но и сегодня то, что `eval` может быть описана на самом Лиспе, даёт возможность легко экспериментировать с новыми вариантами реализации вычислений или отладки.

  - Наконец, сама по себе `eval` способна быть инструментом программирования.
    Достаточно спорным инструментом, так как использование `eval` требует присутствия в памяти целого интерпретатора или компилятора во время исполнения кода.
    Кроме того, в таком случае становится невозможным применять некоторые оптимизации.
    Другими словами, использование `eval` имеет свою цену.
    В некоторых случаях её использование полностью оправдано,
    к примеру, когда Лисп используется для описания и реализации метаязыков.

    Кроме ощутимой стоимости использования, семантика `eval` часто неоднозначна.
    Именно поэтому она вообще не входила в стандарт Scheme до ревизии R<sup>5</sup>RS
    [[CR91b]](zz_bibliography.html#cr91b), [[KCR98]](zz_bibliography.html#kcr98).
    Мы рассмотрим этот вопрос подробнее [в восьмой главе](ch08/00_evaluation_and_reflection.html).
